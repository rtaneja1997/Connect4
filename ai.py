#ai stuff
import numpy as np
import pygame
import sys
import math
import random
import connect4
import copy 
from connect4 import *


DEPTH=4 

class MoveInfo(object):
	"""Keeps track of a move and its minimax value"""
	def __init__(self, score,move=None):
		self.move=move 
		self.score=score 

	def __str__(self): 
		
		return "Playing column " + str(self.move) + " has value " + str(self.score) 

	def __repr__(self):

		return self.__str__() 

def play_random(column):
	"""Randomly chooses open column"""
	col=random.randint(0, column-1) 
	return col

def play_smart(board):
	"""uses minimax to play game """
	best_move=minimax(board,1, DEPTH) 
	return best_move.move 



#HELPER FUNCTIONS 

def winning_board(board, player): 
	"""returns true if the player wins the game
	four pieces in a row
	four pieces in a column
	four pieces diagonally aligned"""
	return has_winning_row(board,player) or has_winning_column(board,player) or has_winning_diag(board, player) 


def has_winning_row(board,player): 
	num_rows=len(board) 
	num_cols=len(board[0]) 
	for row in range(num_rows):
		if four_consecutive(board[row], player): 
			return True 
	return False 

def has_winning_column(board, player): 
	num_rows=len(board) 
	num_cols=len(board[0]) 
	for col in range(num_cols):
		current_column=[] 
		for row in range(num_rows):
			current_column.append(board[row][col])
		if four_consecutive(current_column, player): 
			return True 
	return False 

def has_winning_diag(board, player): 
	num_rows=len(board) 
	num_cols=len(board[0]) 

	#positively sloped diagonals
	for c in range(num_cols-3):
		for r in range(num_rows-3):
			if board[r][c] == player and board[r+1][c+1] == player and board[r+2][c+2] == player and board[r+3][c+3] == player:
				return True

	# Check negatively sloped diaganols
	for c in range(num_cols-3):
		for r in range(3, num_rows):
			if board[r][c] == player and board[r-1][c+1] == player and board[r-2][c+2] == player and board[r-3][c+3] == player:
				return True

	#negative sloped diagonals 

def four_consecutive(row, player): 
	"""Returns true if player has four consecutive pieces aligned """
	curr_col=0 
	while curr_col<len(row)-3: 
		is_consecutive=(row[curr_col]==player) and (row[curr_col]==row[curr_col+1]==row[curr_col+2]==row[curr_col+3])
		if is_consecutive:
			return True 
		curr_col+=1 

	return False 



#ACTUAL MINIMAX LOGIC 

def get_possible_moves(board): 
	"""gets available moves for given board """

	print (poss_moves)
	num_cols=len(board[0]) 
	for col in range(num_cols): 
		if connect4.is_valid_location(board,col): 
			poss_moves.append(col) 
	return poss_moves 


def minimax(board, turn, depth): 
	"""performs minimax algorithm on board bounded by [depth] value given """
	
	possible_moves=get_possible_moves(board) 
	
	#Case 1: board is a winning state for human
	if winning_board(board,1):
		return MoveInfo(-1)

	#Case 2: board is a winning state for ai
	elif winning_board(board,2): 
	    return MoveInfo(1) 

    #Case 3: tie 
	elif depth==0 or possible_moves==[]:
		return MoveInfo(0) 

	move_information=[] #keeps track of minimax values for moves 

	for move in possible_moves:

		#get board generated by playing move
		if turn==0:
			piece_type=1
		else:
			piece_type=2 

		new_board=copy.deepcopy(board) 
		row=connect4.get_next_open_row(new_board, move) 
		connect4.drop_piece(new_board, row, move, piece_type) 

		#minimax on board 
		move_info=minimax(new_board, (turn+1)%2, depth-1)
		move_info.move=move 

		#track move information 
		move_information.append(move_info) 

	#maximize score for ai

	if turn==1: 
		bestScore=-10000
		curr_idx=0 
		best_idx=0 
		while curr_idx<len(move_information): 
			if move_information[curr_idx].score>bestScore:
				bestScore=move_information[curr_idx].score 
				best_idx=curr_idx 
			curr_idx+=1 
		return move_information[best_idx] 

	#minimize score for ai 
	bestScore=10000
	curr_idx=0 
	best_idx=0 
	while curr_idx<len(move_information): 
		if move_information[curr_idx].score<bestScore:
			bestScore=move_information[curr_idx].score
			best_idx=curr_idx
		curr_idx+=1 
	return move_information[best_idx]



